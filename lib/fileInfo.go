package lib

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"os"
	"sync"
	"time"
)

// FileInfoList is a list of FileInfo records that gets dumped into JSON file
// for minimizing the amount of necessary processing of new / updated files.
type FileInfoList []FileInfo

// FileInfo type is to keep data about input folder files that have been processed
type FileInfo struct {
	InputName   string
	OutputName  string
	MD5         string    `json:",omitempty"`
	Size        int64     // Excessive data in case MD5 appears the same
	CreatedAt   time.Time // Excessive data in case MD5 appears the same
	ProcessedAt time.Time
	// A hidden flag for processing removal data from JSON only
	FileFound bool `json:"-"`
}

func unmarshalJSON(r io.Reader) (*FileInfoList, error) {
	var result FileInfoList
	if err := json.NewDecoder(r).Decode(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

func marshalJSON(w io.Writer, data *FileInfoList) error {
	encoder := json.NewEncoder(w)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

var mtx sync.Mutex

// ProcessChangedFilesOnly will check if the input folder has any changes by comparing files against the
// info saved in fileInfoListJSONFullFileName file, which will be generated and saved if does not exist.
//
// For every new/updated file an processFileFunc will be called assuming it will produce an outputFile
// which name will be generated by calling outputFileName func. Necessity to call processFileFunc also
// arises naturally if outputFile is absent.
//
// To help with filtering the files to process, isInputFileForProcessing should be provided.
//
// To help sanitize output folder, beforeDeleteCallback may return false to ignore the file from deletion
// and return true to let the file in output folder be deleted. It will only be called for files that
// can be deleted according to fileInfoList.
//
// When nil is passed for beforeDeleteCallback, no deletion for any file will happen.
func ProcessChangedFilesOnly(
	inputFolderName string,
	outputFolderName string,
	outputFileName func(inputFileName string) string,
	isInputFileForProcessing func(inputFolderName, inputFileName string) bool,
	fileInfoListJSONFullFileName string,
	processFileFunc func(fullInputFileName string, fullOutputFileName string) (int, error),
	beforeDeleteCallback func(folderName, fileName string) bool) error {

	// We don't want this function to be called simultaneously
	mtx.Lock()
	defer mtx.Unlock()

	osInputFolderFiles, err := ioutil.ReadDir(inputFolderName)
	if err != nil {
		return fmt.Errorf("input folder read dir error: %w", err)
	}

	var fileInfoList FileInfoList

	// Restore data from the file, if exists
	file, err := os.Open(fileInfoListJSONFullFileName)
	if err != nil {
		// If the file doesn't exist, we'll generate it
	} else {
		defer file.Close()
		result, err := unmarshalJSON(file)
		if err != nil {
			// We simply assume that if we can't unmarshal the file, then it could be safely replaced.
		} else {
			fileInfoList = append(fileInfoList, *result...)
		}
	}

	// Now we'll read the folder and see if data has existed in JSON
	for _, f := range osInputFolderFiles {
		inputFileName := f.Name()
		if !f.IsDir() && isInputFileForProcessing(inputFolderName, inputFileName) {
			outputFileName := outputFileName(inputFileName)

			foundIndex := -1
			processedMD5 := "" // To avoid calculating it twice
			processIt := false
			for index, fileInfo := range fileInfoList {
				if fileInfo.InputName == inputFolderName+"/"+inputFileName {
					foundIndex = index
					newMD5 := GetFileMD5(inputFolderName + "/" + inputFileName)
					// The file has changed?
					if fileInfo.Size != f.Size() || fileInfo.CreatedAt != f.ModTime() || fileInfo.MD5 != newMD5 {
						processIt = true
						processedMD5 = newMD5
					}
					// The output file doesn't exist?
					if _, err := os.Stat(outputFolderName + "/" + outputFileName); os.IsNotExist(err) {
						processIt = true
						processedMD5 = newMD5
					}
					fileInfoList[index].FileFound = true // Mark it as found so it won't be removed (Can't do fileInfo.FileFound, since it's a copy)
					break
				}
			}

			if foundIndex < 0 || processIt {
				processFileFunc(inputFolderName+"/"+inputFileName, outputFolderName+"/"+outputFileName)
				if processedMD5 == "" {
					processedMD5 = GetFileMD5(inputFolderName + "/" + inputFileName)
				}
				if foundIndex < 0 {
					fileInfoList = append(fileInfoList, FileInfo{
						InputName:   inputFolderName + "/" + inputFileName,
						OutputName:  outputFolderName + "/" + outputFileName,
						MD5:         processedMD5,
						Size:        f.Size(),
						CreatedAt:   f.ModTime(),
						ProcessedAt: time.Now(),
						FileFound:   true, // Mark it as found so it won't be removed
					})
				} else {
					fileInfoList[foundIndex].MD5 = processedMD5
					fileInfoList[foundIndex].Size = f.Size()
					fileInfoList[foundIndex].CreatedAt = f.ModTime()
					fileInfoList[foundIndex].ProcessedAt = time.Now()
					fileInfoList[foundIndex].FileFound = true // Mark it as found so it won't be removed
				}
			}
		}
	}
	// Get rid of the ones were in JSON that were not found as files (due to "fileFound" flag)
	for index := 0; index < len(fileInfoList); index++ {
		if !fileInfoList[index].FileFound {
			fileInfoList = append(fileInfoList[:index], fileInfoList[index+1:]...)
			index-- // To make it re-run the index that will be index++
		}
	}

	out, err := os.Create(fileInfoListJSONFullFileName)
	if err != nil {
		return fmt.Errorf("can't create json file info file: %w", err)
	}
	defer out.Close()

	err = marshalJSON(out, &fileInfoList)
	if err != nil {
		return fmt.Errorf("error marshalling json: %w", err)
	}

	// And now we'll remove the unnecessary files from output folder that don't exist in JSON
	// Remove unnecessary files from output folder
	return SanitizeOutputFolder(outputFolderName, beforeDeleteCallback, &fileInfoList)
}

// ProcessChangedFilesOnlyRecursively walks through inputFolderName and all subfolders of it recursively
// and executes ProcessChangedFilesOnly against every found folder.
// The difference between ProcessChangedFilesOnly and ProcessChangedFilesOnlyRecursively
// is also that fileInfoListJSONFullFileName is a function that receives inputFolderName argument for every
// folder visited.
func ProcessChangedFilesOnlyRecursively(
	inputFolderName string,
	outputFolderName string,
	outputFileName func(inputFileName string) string,
	isInputFileForProcessing func(inputFolderName, inputFileName string) bool,
	fileInfoListJSONFullFileName func(inputFolderName string) string,
	processFileFunc func(fullInputFileName string, fullOutputFileName string) (int, error),
	beforeDeleteCallback func(folderName, fileName string) bool) error {

	osInputFolderFiles, err := ioutil.ReadDir(inputFolderName)
	if err != nil {
		return fmt.Errorf("input folder read dir error: %w", err)
	}

	err = ProcessChangedFilesOnly(inputFolderName,
		outputFolderName,
		outputFileName,
		isInputFileForProcessing,
		fileInfoListJSONFullFileName(inputFolderName),
		processFileFunc,
		beforeDeleteCallback)
	if err != nil {
		return err
	}

	for _, f := range osInputFolderFiles {
		if f.IsDir() {
			err := ProcessChangedFilesOnlyRecursively(inputFolderName + "/" +f.Name(),
				outputFolderName + "/" + f.Name(),
				outputFileName,
				isInputFileForProcessing,
				fileInfoListJSONFullFileName,
				processFileFunc,
				beforeDeleteCallback)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// SanitizeOutputFolder is automatically called after each ProcessChangedFilesOnly call but can also be called manually.
//
// SanitizeOutputFolder removes all the files from outputFolderName that were not found in JSON's fileInfoList. We will also ignore files we
// are not supposed to touch by means of beforeDeleteCallback function which is expected to return true for files that can be deleted.
//
// If beforeDeleteCallback function is not provided, we assume that no sanitizing should happen. But it only calls
// it in case the file is definitely not in the fileInfoList.
//
// Returns a wrapped error in case output folder didn't exist or file's removal failed.
func SanitizeOutputFolder(
	outputFolderName string,
	beforeDeleteCallback func(folderName, fileName string) bool,
	fileInfoList *FileInfoList) error {

	if beforeDeleteCallback == nil {
		return nil
	}

	outputFolderFiles, err := ioutil.ReadDir(outputFolderName)
	if err != nil {
		return fmt.Errorf("output folder scan error: %w", err)
	}
	for _, f := range outputFolderFiles {
		if !f.IsDir() && !isInFileInfoListAsOutputName(fileInfoList, outputFolderName, f.Name()) {
			if beforeDeleteCallback(outputFolderName, f.Name()) {
				if err := os.Remove(outputFolderName + "/" + f.Name()); err != nil {
					return fmt.Errorf("remove file error: %w", err)
				}
			}
		}
	}
	return nil
}

func isInFileInfoListAsInputName(list *FileInfoList, inputFolderName, item string) bool {
	for _, l := range *list {
		if l.InputName == (inputFolderName + "/" + item) {
			return true
		}
	}
	return false
}

func isInFileInfoListAsOutputName(list *FileInfoList, outputFolderName, item string) bool {
	for _, l := range *list {
		if l.OutputName == (outputFolderName + "/" + item) {
			return true
		}
	}
	return false
}

// GetFileMD5 will open the file, calculate and return its MD5 as a sequence of Hex symbols
func GetFileMD5(fileName string) string {
	const fileChunk = 8192 // we settle for 8KB
	file, err := os.Open(fileName)
	if err != nil {
		return "" // simply skip the file that has been removed
	}
	defer file.Close()
	info, _ := file.Stat()
	fileSize := info.Size()
	blocks := uint64(math.Ceil(float64(fileSize) / float64(fileChunk)))
	hash := md5.New()
	for i := uint64(0); i < blocks; i++ {
		blockSize := int(math.Min(fileChunk, float64(fileSize-int64(i*fileChunk))))
		buf := make([]byte, blockSize)
		file.Read(buf)
		io.WriteString(hash, string(buf)) // append into the hash
	}
	return fmt.Sprintf("%x", hash.Sum(nil))
}
