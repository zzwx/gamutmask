package cli

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"os"
	"sync"
	"time"
)

// FileInfoList is simply a list of file infos that gets dumped into JSON file
type FileInfoList []FileInfo

// FileInfo type is used to keep track of modified files
type FileInfo struct {
	InputName   string
	OutputName  string
	MD5         string    `json:",omitempty"`
	Size        int64     // Excessive data in case MD5 appears the same
	CreatedAt   time.Time // Excessive data in case MD5 appears the same
	ProcessedAt time.Time
	// A hidden flag for processing removal data from JSON only
	FileFound bool `json:"-"`
}

func unmarshalJSON(r io.Reader) (*FileInfoList, error) {
	var result FileInfoList
	if err := json.NewDecoder(r).Decode(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

func marshalJSON(w io.Writer, data *FileInfoList) error {
	encoder := json.NewEncoder(w)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

var mtx sync.Mutex

// ProcessChangedFilesOnly will check if the input folder has any changes by comparing files against the
// info saved in fileInfoListJSONFullFileName file, which will be generated and if does not exist.
// For every new/updated file an processFileFunc will be called assuming it will produce an outputFile
// which name will be generated by calling outputFileName func. Necessity to call processFileFunc also
// arises if outputFile is absent.
// To help with filtering files to process, isInputFileForProcessing should be provided.
// To help sanitize output folder, isOutputFileSanitizable function will be called which will allow
// to skip the files that shouldn't be touched.
func ProcessChangedFilesOnly(
	inputFolderName string,
	outputFolderName string,
	outputFileName func(inputFileName string) string,
	isInputFileForProcessing func(inputFolderName, inputFileName string) bool,
	isOutputFileSanitizable func(outputFolderName, outputFileName string) bool,
	fileInfoListJSONFullFileName string,
	processFileFunc func(fullInputFileName string, fullOutputFileName string) (int, error)) {

	// We don't want this function to be called simultaneously
	mtx.Lock()
	defer mtx.Unlock()

	osInputFolderFiles, err := ioutil.ReadDir(inputFolderName)
	if err != nil {
		panic(err)
	}

	var fileInfoList FileInfoList

	// Restore data from the file, if exists
	file, err := os.Open(fileInfoListJSONFullFileName)
	if err != nil {
		// If the file doesn't exist, we'll generate it
	} else {
		result, err := unmarshalJSON(file)
		if err != nil {
			//panic(err)
			// We just skip if the file doesn't contain right data
		} else {
			fileInfoList = append(fileInfoList, *result...)
		}
	}
	defer file.Close()

	// Now we'll read the folder and see if data has existed in JSON
	for _, f := range osInputFolderFiles {
		inputFileName := f.Name()
		if !f.IsDir() && isInputFileForProcessing(inputFolderName, inputFileName) {
			outputFileName := outputFileName(inputFileName)

			foundIndex := -1
			processedMD5 := "" // To avoid calculating it twice
			processIt := false
			for index, fileInfo := range fileInfoList {
				if fileInfo.InputName == inputFolderName+"/"+inputFileName {
					foundIndex = index
					newMD5 := GetFileMD5(inputFolderName + "/" + inputFileName)
					// The file has changed?
					if fileInfo.Size != f.Size() || fileInfo.CreatedAt != f.ModTime() || fileInfo.MD5 != newMD5 {
						processIt = true
						processedMD5 = newMD5
					}
					// The output file doesn't exist?
					if _, err := os.Stat(outputFolderName + "/" + outputFileName); os.IsNotExist(err) {
						processIt = true
						processedMD5 = newMD5
					}
					fileInfoList[index].FileFound = true // Mark it as found so it won't be removed (Can't do fileInfo.FileFound, since it's a copy)
					break
				}
			}

			if foundIndex < 0 || processIt {
				processFileFunc(inputFolderName+"/"+inputFileName, outputFolderName+"/"+outputFileName)
				if processedMD5 == "" {
					processedMD5 = GetFileMD5(inputFolderName + "/" + inputFileName)
				}
				if foundIndex < 0 {
					fileInfoList = append(fileInfoList, FileInfo{
						InputName:   inputFolderName + "/" + inputFileName,
						OutputName:  outputFolderName + "/" + outputFileName,
						MD5:         processedMD5,
						Size:        f.Size(),
						CreatedAt:   f.ModTime(),
						ProcessedAt: time.Now(),
						FileFound:   true, // Mark it as found so it won't be removed
					})
				} else {
					fileInfoList[foundIndex].MD5 = processedMD5
					fileInfoList[foundIndex].Size = f.Size()
					fileInfoList[foundIndex].CreatedAt = f.ModTime()
					fileInfoList[foundIndex].ProcessedAt = time.Now()
					fileInfoList[foundIndex].FileFound = true // Mark it as found so it won't be removed
				}
			}
		}
	}
	// Get rid of the ones were in JSON that were not found as files (due to "fileFound" flag)
	for index := 0; index < len(fileInfoList); index++ {
		if !fileInfoList[index].FileFound {
			fileInfoList = append(fileInfoList[:index], fileInfoList[index+1:]...)
			index-- // To make it re-run the index that will be index++
		}
	}

	out, err := os.Create(fileInfoListJSONFullFileName)
	if err != nil {
		panic(err)
	}
	defer out.Close()

	marshalJSON(out, &fileInfoList)

	// And now we'll remove the unnecessary files from output folder that don't exist in JSON
	// Remove unnecessary files from output folder
	SanitizeOutputFolder(outputFolderName, isOutputFileSanitizable, &fileInfoList)

}

// SanitizeOutputFolder removes files that were not found in JSON's fileInfoList. We will also ignore files we
// are not supposed to touch by means of filter function which will only return true for files of interest
func SanitizeOutputFolder(outputFolderName string, isOutputFileSanitizable func(outputFolderName, outputFileName string) bool, fileInfoList *FileInfoList) {
	outputFolderFiles, err := ioutil.ReadDir(outputFolderName)
	if err != nil {
		panic(err)
	}
	for _, f := range outputFolderFiles {
		if isOutputFileSanitizable(outputFolderName, f.Name()) {
			if !f.IsDir() && !isInFileInfoListAsOutputName(fileInfoList, outputFolderName, f.Name()) {
				fmt.Printf("Deleting: %v\n", outputFolderName+"/"+f.Name())
				if err := os.Remove(outputFolderName + "/" + f.Name()); err != nil {
					panic(err)
				}
			}
		}
	}

}

func isInFileInfoListAsInputName(list *FileInfoList, inputFolderName, item string) bool {
	for _, l := range *list {
		if l.InputName == (inputFolderName + "/" + item) {
			return true
		}
	}
	return false
}

func isInFileInfoListAsOutputName(list *FileInfoList, outputFolderName, item string) bool {
	for _, l := range *list {
		if l.OutputName == (outputFolderName + "/" + item) {
			return true
		}
	}
	return false
}

// GetFileMD5 will open the file, calculate and return its MD5 as a sequence of Hex symbols
func GetFileMD5(fileName string) string {
	const fileChunk = 8192 // we settle for 8KB
	file, err := os.Open(fileName)
	if err != nil {
		return "" // skip the file that has been removed
		//panic(err)
	}
	defer file.Close()
	info, _ := file.Stat()
	fileSize := info.Size()
	blocks := uint64(math.Ceil(float64(fileSize) / float64(fileChunk)))
	hash := md5.New()
	for i := uint64(0); i < blocks; i++ {
		blockSize := int(math.Min(fileChunk, float64(fileSize-int64(i*fileChunk))))
		buf := make([]byte, blockSize)
		file.Read(buf)
		io.WriteString(hash, string(buf)) // append into the hash
	}
	return fmt.Sprintf("%x", hash.Sum(nil))
}
